
import * as React from 'react';
import {Model, CanvasEvent} from 'free-canvas-shared'
import {DragProp,DragState} from './type'



type MouseListener = (e:MouseEvent)=>void


export class Drag extends React.Component<DragProp,DragState>{
    private _isDragging:boolean = false
    private _prevX:number
    private _prevY:number
    static onMouseMoveQueue:MouseListener[] = []
    static onMouseUpQueue:MouseListener[] = []
    constructor(props:DragProp){
        super(props);
        this.state = {
            
        }
        this.onDragMove.bind(this)
        this.onDragEnd.bind(this)
        Drag.onMouseMoveQueue.push(this.onDragMove)
        Drag.onMouseUpQueue.push(this.onDragEnd)
    }
    componentWillUnmount(){
        Drag.onMouseMoveQueue.splice(Drag.onMouseMoveQueue.indexOf(this.onDragMove),1);
        Drag.onMouseMoveQueue.splice(Drag.onMouseMoveQueue.indexOf(this.onDragEnd),1);
    }
    static OnGlobalMoseMove(e:MouseEvent){
        Drag.onMouseMoveQueue.forEach((fn)=>fn(e));
    }
    static OnGlobalMoseUp(e:MouseEvent){
        Drag.onMouseUpQueue.forEach((fn)=>fn(e));
    }
    onDragStart=(e:React.MouseEvent)=>{
        const {clientX,clientY} = e;
        this._prevX = clientX;
        this._prevY = clientY;
        if(!this._isDragging){
            const {onDragStart,data} = this.props;
            const targetEl = onDragStart(data,clientX,clientY);
            // const dataTransfer = e.dataTransfer;
            // dataTransfer.effectAllowed = 'move'
            // dataTransfer.dropEffect = 'move'
            // dataTransfer.setDragImage(targetEl,0,0);
            // dataTransfer.setDragImage(document.createElement('div'),0,0);
        }
        this._isDragging = true
    }
    onDragMove=(e:MouseEvent)=>{
        console.log('_isDragging :',this._isDragging);
        if(!this._isDragging) return;
        const {clientX,clientY,pageX,pageY,screenX,screenY} = e;
        // const {x,y} = e.nativeEvent
        // console.log(e.nativeEvent);
        console.log(clientX,clientY,pageX,pageY,screenX,screenY);
        if(this._prevX === clientX && this._prevY === clientY) return;
        this._prevX = clientX;
        this._prevY = clientY;
        const {onDragMove} = this.props;
        onDragMove(clientX,clientY);
        e.preventDefault();
    }
    onDragEnd=(e:MouseEvent)=>{
        // e.dataTransfer.clearData();
        const {onDragEnd} = this.props;
        onDragEnd();
        this._isDragging = false
        // e.preventDefault();
    }
    render(){
        const {className,children} = this.props;
        return <div className={className}
        onMouseDown={this.onDragStart}
        >
            {children}
        </div>
    }
}

document.body.addEventListener(CanvasEvent.MOUSEMOVE,Drag.OnGlobalMoseMove)
document.body.addEventListener(CanvasEvent.MOUSEUP,Drag.OnGlobalMoseUp)